Частина А - Теорія

1) Поясніть різницю між інкапсуляцією, успадкуванням, поліморфізмом та
абстракцією.

Інкапсуляція - приховування внутрішньої реалізації або логіки обʼєкта від зовнішнього світу(private, protected, public)
Абстракція - відділення ключових характеристик обʼєкта від другорядних деталей
Поліморфізм - використання одного інтерфейсу для різних типів даних або обʼєктів
Наслідування - успадкування якихось характеристик, властивостей або поведінки від іншого класу

2) Агрегація vs композиція: що спільного, що відмінного? Наведіть приклад кожної.

Агрегація - це коли один обʼєкти можуть інснувати незалежно один від одного. Наприклад: школа і вчителі, вчителі можуть існувати незадежно від школи
Композиція - це коли обʼєкти повність залежать один від одного, обʼєкт створюється всередині іншого класу. Наприклад: клас автомобіль, що складається з класів двигун і колеса

Спільне і відмінне: обидва використовуються для роботи з класами, в обох випадках клас має інший, тип зв'язку(агрегація - слабкий зв'язок, композиція - сильний), при 
знищенні основного при агрегації не знищується підлеглі об'єкти, а при композиції коли знищується основний об'єкт знищуються і підлеглі

Отже, агрегація - має але не володія, а композиція має і володіє

3) Що таке віртуальна функція? Навіщо потрібні override?

Virtual функція - це функція, яка оголошується в батьківському класі і яка може бути перевизначена в дочерних класах
override використовуються щоб показати компілятору, що ви хочете перевизначити віртуальну функцію з батьківського класу

4) Абстрактний клас і чисто віртуальна функція — визначення та мета.

Абстрактний клас - це клас, який служить шаблоном для дочерних класів, створюючи спільний інтерфейс
Чисто віртуальна функція - це це метод оголошений в абстрактному класі без реалізації. Наприклад: virtual void f1() = 0;

5) unique_ptr vs shared_ptr. Коли що застосовувати?

unique_ptr - використовуються для одноосібного володіння. Використовується коли ви точно знаєте, що об'єкт точно має тільки 1 власника
shared_ptr - це коли кілька покажчиків володіють одним ресурсом. Використовується коли об'єкт потребує множинного доступу та спільного володіння

6) Порівняйте vector і list за складністю вставок/доступу/кеш-локальності 

vector - ефективний тоді коли потрібно часто зветатись за елемантами по індексах, його головною перевагою є висока швидікість доступу та добра кеш локальності. 
Недоліком є повільні вставки і видалення всередині
list - навпаки зручний для вставок і видалень в будь-якому місці, проте доступ до елементів повільний, а кеш локальность низька, бо елеманти зберігаються у різних 
частинах пам'яті

7) Як безпечно видаляти елементи з vector за умовою (erase/remove_if і чому так).

remove_if переміщує всі елементи, які повинні бути видалені на початок вектора і повертає ітератор на перший елемнент який потрібно видалити 
пісця чого erase видаляє всі елементи починаючи з цього ітератора до кінця вектора. Це безпечно оскільки remove_if не змінює розмір вектора, а переставляє елементи, 
що гарантує правельнне поводження з ітераторами під час роботи

8) Базовий шаблон try/catch у C++. Які стандартні типи винятків знаєте? (#include <exception>)

exception - базовий для всіх стандартиних випадків 
runtime_error - для помилок під час виконання програм 
logic_error - для помилок логіки програми 
overflow_error / underflow_error - переповнення / недоповнення при обчисленнях 
domain_error - невірна область визначення функції 
length_error - порушення обмежень довжини

Наприклад: 

#include <iostream>
#include <exception>
using namespace std;

int main() {
    try {
        throw runtime_error("Error!");
    }
    catch (const runtime_error& e) {
        cout << "runtime_error: " << e.what() << endl;
    }
    catch (const exception& e) {
        cout << "Error: " << e.what() << endl;
    }
    return 0;
}

9) C-файли: різниця між текстовим і двійковим режимом; що таке буфер і поточна позиція (fseek/ftell).

Відкриття текстового файлу:

#include <fstream>
using namespace std;

ofstream out("file.txt");
ifstream in("file.txt");

Відкриттня двійкового файлу:

ofstream out("file.bin", ios::binary);
ifstream in("file.bin", ios::binary);

Відмінності: текстовий транслює символи кінця рядка, двійковий точне збереження байтів без змін

Потоки в cpp використовують буфер для підвищеного читання / запису у файл 
Вивідний буфер - ofstream
Вхідний буфер - ifstream

tellg() -- ifstream / fstream -- повертає поточну позицію читання
tellp()	-- ofstream / fstream -- повертає поточну позицію запису
seekg(pos, dir)	-- ifstream / fstream -- переміщує позицію читання
seekp(pos, dir)	-- ofstream / fstream -- переміщує позицію запису


10) JSON: що таке json::value, як створити масив об’єктів і зберегти його у файл.

json::value - це універсальний контейнер для для будь яких json даних

Приклад створення мисиву об'єктів і передача їх у файл:

#include <nlohmann/json.hpp>
#include <fstream>
using json = nlohmann::json;
using namespace std;

int main() {
    json people = json::array();

    people.push_back({ {"name", "Alice"}, {"age", 25} });
    people.push_back({ {"name", "Bob"}, {"age", 30} });
    people.push_back({ {"name", "Charlie"}, {"age", 22} });

    ofstream file("people.json");
    file << people.dump(4);
    file.close();
}